<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Chicago Crime Map with Line and Doughnut Charts</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
  <style>
    /* === Base Layout === */
    body {
      margin: 0;
      font-family: sans-serif;
      background: #f3f3f3;
    }
  
    #dashboard {
      display: flex;
      height: 100vh;
      width: 100vw;
      gap: 20px;
      padding: 20px;
      box-sizing: border-box;
      overflow: hidden;
    }

    .summary-btn {
      background-color: #b54833;
      color: white;
      text-decoration: none;
      font-size: 14px;
      font-weight: 600;
      padding: 10px 16px;
      border-radius: 6px;
      transition: background-color 0.2s ease;
      flex-shrink: 0;
      height: 36px;
      box-sizing: border-box
    }

    .summary-btn:hover {
      background-color: #a33f2b;
    }
  
    /* === Shared Card Styles === */
    .card {
      background: white;
      border-radius: 6px;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.08);
      padding: 16px;
      width: 100%;
      box-sizing: border-box;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }
  
    .card.hidden {
      display: none;
      opacity: 0;
    }
  
    .card h3 {
      margin-top: 0;
      font-size: 16px;
      color: #333;
    }
  
    /* === Map Panel === */
    #map-panel {
      flex: 7;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      padding: 16px;
      background: white;
      box-sizing: border-box;
    }
  
    .map-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding-bottom: 8px;
      padding: 10px 0;
      background: white;
      font-size: 18px;
      font-weight: 600;
      color: #333;
      letter-spacing: 0.4px;
      position: relative;
      z-index: 2;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.04);
      border-radius: 6px 6px 0 0;
      gap: 15px;
    }

    .header-left-content {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      flex-shrink: 1;
      margin-right: 10px;
    }

    .map-header .header-left-content { 
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      flex-shrink: 1;
      margin-right: 10px;
      /*width: fit-content;*/
    }

    .map-header h3 {
      margin-bottom: 3px;
      margin: 0;
      white-space: nowrap; 
      flex-shrink: 0; 
      font-size: 18px;
      font-weight: 600;
      line-height: 1.1;
    }

    .header-description {
      font-size: 10px;  
      color: #666;
      line-height: 1.3;
      margin: 0;
      padding: 0; 
      max-width: 40ch; 
    }

    #sort-toggle {
    margin-top: 2px;
    align-self: flex-start; 
    }
  
    .map-wrapper {
      flex: 1;
      background: transparent;
      border-radius: 8px;
      overflow: hidden;
    }
  
    #map {
      width: 100%;
      height: 100%;
      background: #f3f3f3;
      position: relative;
      padding: 0; /* optional */
    }
  
    #map svg {
      transform: scale(0.98);
      transform-origin: center;
      display: block;
      margin: 0 auto;
    }
  
    #map path {
      fill: #dddddd;
      stroke: #999;
      stroke-width: 0.5;
    }
  
    #map path.community {
      transition: fill 0.3s ease, stroke 0.3s ease;
      cursor: pointer;
    }
  
    #map path.community:hover {
      stroke: #333;
      stroke-width: 1.2;
      filter: brightness(1.1);
    }
  
    .selected {
      fill: #bdbcbc !important;
      stroke: #333 !important;
      stroke-width: 1.5;
    }
  
    .dimmed {
      opacity: 0.6;
    }

    #static-grid .card {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      color: #666;
      background: #fafafa;
      border: 1px solid #ddd;
      height: 150px; /* Or adjust */
    }

  
    /* === Crime Spikes === */
    polygon.spike {
      fill: #ff5252;
      opacity: 0.5;
      pointer-events: none;
    }
  
    /* === Doughnut Panel === */
    #doughnut-panel {
      flex: 3;
      height: 100%;
      max-height: 100%;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      box-sizing: border-box;
      gap: 12px;
    }
  
    #doughnut {
      width: 100%;
    }
  
    #doughnut h2 {
      font-size: 16px;
      margin-bottom: 10px;
    }
  
    #doughnut-chart {
      width: 100%;
      height: auto;
      aspect-ratio: 1 / 1;
      max-width: 300px;
      margin: 0 auto;
      display: block;
    }

    #doughnut-tooltip {
      position: absolute;
      background: white;
      border: 1px solid #ccc;
      padding: 8px 12px;
      font-size: 12px;
      border-radius: 4px;
      pointer-events: none;
      opacity: 0;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
      z-index: 20;
    }
      
    /* === Legend === */
    #legend {
      margin-top: 5px;
      font-size: 12px;
    }

    .legend-item {
      display: flex;
      align-items: center;
      margin-bottom: 2px;
      padding: 2px 4px;
      border-radius: 2px;
      cursor: pointer;
      transition: background-color 0.2s ease;
    }

    .legend-item:hover {
      background-color: #f2f2f2;
    }

    .legend-item.clicked {
      background-color: #e6f0ff;
    }

    .legend-swatch {
      width: 14px;
      height: 14px;
      margin-right: 6px;
      border-radius: 2px;
    }
  
    /* === Indicators Panel === */
    #indicators-card {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    #indicators-card .map-header {
      padding-left: 0;
      padding-right: 0;
    }
  
    #indicators {
      flex: 1;
      overflow-y: auto;
      overflow-x: hidden;
      margin-top: 12px;
    }
  
    #indicators::-webkit-scrollbar {
      width: 6px;
    }
  
    .indicator-row {
      margin-bottom: 8px;
      font-family: sans-serif;
    }
  
    .indicator-label {
      font-size: 12px;
      margin-bottom: 4px;
      color: #333;
    }
  
    .indicator-bar-container {
      height: 12px;
      background: #eee;
      border-radius: 3px;
      width: 100%;
      overflow: hidden;
      box-sizing: border-box;
    }
  
    .indicator-bar-fill {
      background: #4c6ef5;
      height: 100%;
      border-radius: 3px 0 0 3px;
      max-width: 100%;
      transition: width 0.4s ease;
    }
  
    .indicator-value {
      font-size: 10px;
      color: #333;
      white-space: nowrap;
      background: none;
      margin-left: 8px;
      flex-shrink: 0;
      position: static;
    }
  
    /* === Tooltip === */
    .tooltip {
      position: absolute;
      background: white;
      border: 1px solid #ccc;
      border-left: 4px solid #4c6ef5;
      padding: 12px 16px;
      font-size: 13px;
      color: #222;
      pointer-events: none;
      opacity: 0;
      max-width: 320px;
      border-radius: 8px;
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
      transition: top 0.2s ease, left 0.2s ease, opacity 0.2s ease;
      z-index: 10;
    }
  
    .tooltip svg {
      width: 280px;
      height: 120px;
      background: #ffffff;
      margin-top: 5px;
    }
  
    #tooltip-chart path {
      fill: lightblue;
      stroke: steelblue;
      stroke-width: 1.0;
    }
  
    /* === SVG Global === */
    svg {
      width: 100%;
      height: 100%;
      overflow: visible;
    }
  
    /* === Utility === */
    .hidden {
      display: none;
    }
    
    .search-container {
    flex-grow: 1;
    max-width: 350px;
    margin-left: auto;
    }

    #ca-search {
      width: 100%;
      padding: 6px 10px;
      font-size: 13px;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-sizing: border-box;
      height: 36px;
    }

    /* Animation for sliding in/out */
    .slide-in {
      animation: slideIn 0.4s ease forwards;
    }

    .slide-out {
      animation: slideOut 0.4s ease forwards;
    }

    @keyframes slideIn {
      from { transform: translateX(100%); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }

    @keyframes slideOut {
      from { transform: translateX(0); opacity: 1; }
      to { transform: translateX(100%); opacity: 0; }
    }
  </style>  
</head>
<body>

  <div id="dashboard">
  
    <!-- Map Panel -->
    <div id="map-panel" class="card">
      <div class="map-header">
        <h3>Chicago Community Areas</h3>
        <div class="search-container">
          <input type="search" id="ca-search" list="ca-list" placeholder="Search Community Area...">
          <datalist id="ca-list"></datalist>
        </div>
        <a class="summary-btn" href="index.html">→ Go To Summary</a>
      </div>
      <div class="map-wrapper">
        <div id="map">
          <svg></svg>
          <div class="tooltip" id="tooltip">
            <div id="tooltip-header"></div>
            <svg id="tooltip-chart"></svg>
          </div>
        </div>
      </div>
    </div>
  
    <!-- Right Panel -->
    <div id="doughnut-tooltip"></div>
    <div id="doughnut-panel">
      
      <!-- Static Layout (2x2 Grid) -->
      <div id="static-layout" style="display: flex; flex-direction: column; gap: 12px; height: 100%;">
        <!-- Top Row -->
        <div style="display: flex; gap: 12px; flex: 1;">

          <!-- Left Box: Citywide Summary -->
          <div id="static-card" class="card" style="flex: 1; display: flex; flex-direction: column; gap: 8px; padding: 12px;">
            <div class="map-header">
              <h3>Crime Summary</h3>
            </div>

            <!-- Horizontal Stats -->
            <div style="display: flex; gap: 8px; flex-grow: 1;">
              <div style="flex: 1; display: flex; flex-direction: column; justify-content: center; align-items: center; background: #fafafa; border: 1px solid #ddd; border-radius: 6px; padding: 8px;">
                <div id="summary1-content" style="font-size: 20px; font-weight: bold; color: #b54833; text-align: center;">-- %</div>
              </div>
              <div style="flex: 1; display: flex; flex-direction: column; justify-content: center; align-items: center; background: #fafafa; border: 1px solid #ddd; border-radius: 6px; padding: 8px;">
                <div id="summary2-content" style="font-size: 20px; font-weight: bold; color: #b54833; text-align: center;">-- %</div>
              </div>
            </div>
          </div>

          <!-- Right Box: Top Crime Category -->
          <div id="static-extra1" class="card" style="flex: 1; display: flex; flex-direction: column; gap: 8px; padding: 12px;">
            <div class="map-header">
              <h3>Top Crime Category</h3>
            </div>
            <div id="top-category-content" style="margin-top: 8px; font-size: 14px; color: #555;"></div>
          </div>
        </div>

        <!-- Middle Row -->
        <div style="display: flex; gap: 12px; flex: 1;">
          <div id="static-extra2" class="card" style="flex: 1;">
            <h3>Safest Community Areas</h3>
            <div id="safest-ca-content" style="margin-top: 8px; font-size: 14px; color: #555;"></div>
          </div>

          <div id="static-extra3" class="card" style="flex: 1;">
            <h3>Most Crime-Ridden Areas</h3>
            <div id="highest-ca-content" style="margin-top: 8px; font-size: 14px; color: #555;"></div>
          </div>
        </div>
        <!-- Bottom Row -->
        <div style="display: flex; gap: 12px; flex: 1;">
          <div id="static-extra2" class="card" style="flex: 1;">
            <h3>Extra Chart 1</h3>
            <div id="safest-ca-content" style="margin-top: 8px; font-size: 14px; color: #555;"></div>
          </div>

          <div id="static-extra3" class="card" style="flex: 1;">
            <h3>Extra Chart 2</h3>
            <div id="highest-ca-content" style="margin-top: 8px; font-size: 14px; color: #555;"></div>
          </div>
        </div>
        <div class="card" style="flex: 1; display: flex; flex-direction: column; gap: 8px;">
          <h3 style="margin: 0;">Crime Trend Over Time</h3>
        
          <div style="flex: 1; background: #fafafa; border: 1px solid #ddd; border-radius: 6px; padding: 8px; display: flex; justify-content: center; align-items: center;">
            <svg id="static-chart"></svg>
          </div>
        </div>
        
      </div>
  
      <!-- Dynamic Layout (Doughnut + Indicators) -->
      <div id="dynamic-layout" style="display: none; flex-direction: column; gap: 12px;">
        <div id="doughnut" class="card hidden">
          <div class="map-header">
            <h3 id="doughnut-title">Crime by Category</h3>
          </div>
          <svg id="doughnut-chart" width="160" height="160"></svg>
          <div id="legend"></div>
        </div>
  
        <div id="indicators-card" class="card hidden">
          <div class="map-header">
            <div class="header-left-content">
                <h3>Socio-Economic Indicators</h3>
                <div class="header-description">
                  Bar Length: Relative standing compared to other Community Areas
                </div>
            </div>
            <span id="sort-toggle" style="cursor: pointer; font-size: 12px; margin-left: 8px;" title="Sorted by importance (Default CSV order)">⭐</span>
          </div>
          <div id="indicators"></div>
        </div>
      </div>
  
    </div>
  </div> 

<script>
  const svg = d3.select("#map svg");
  const tooltip = d3.select("#tooltip");
  const tooltipHeader = d3.select("#tooltip-header");
  const chartSvg = d3.select("#tooltip-chart");
  const doughnutSvg = d3.select("#doughnut-chart");
  const doughnutTitle = d3.select("#doughnut-title");

  const mapContainer = document.getElementById("map");
  const width = mapContainer.clientWidth || window.innerWidth * 0.6;
  const height = mapContainer.clientHeight || window.innerHeight;

  const spikeWidth = 10;

  let currentScale = 1;
  let currentTranslate = [0, 0];
  let crimeByCategory = [];
  let indicatorScales = [];
  let topFeatures = [];
  let originalIndicatorOrder = []; // <-- Define variable to hold original order
  let currentSortMode = 'importance'; // <-- Define variable for sort state ('importance', 'descending', 'ascending')
  let activeCA = null; // <-- Define activeCA globally in script scope

  Promise.all([
    d3.json("data/chicago.geojson"),
    d3.csv("data/crime_rate_by_crime_type.csv", d3.autoType), // <-- Used for map color & spikes
    d3.csv("data/crime_rate_by_crime_group.csv", d3.autoType), // <-- Used for doughnut chart
    d3.csv("data/top_features_per_CA_sorted.csv", d3.autoType), // <-- Used for indicators
    d3.csv("data/crime_rate_by_crime_group_YEAR.csv", d3.autoType), // <-- Enables filtering by year
    d3.csv("data/CA areas.csv", d3.autoType) // <-- Area data still loaded if needed later
  ]).then(([geojson, crimes, crimeGroup, features, crimeGroupbyYear, caAreas]) => {
    // Initially: Show static card only
    d3.select("#static-card").classed("hidden", false);
    d3.select("#doughnut").classed("hidden", true);
    d3.select("#indicators-card").classed("hidden", true);

    // Filter data
    const maxYearToInclude = 2024; // Example: Include data up to end of 2024
    crimes = crimes.filter(d => d.Year <= maxYearToInclude);
    crimeGroup = crimeGroup.filter(d => d.Year <= maxYearToInclude);
    topFeatures = features; // Assign to the globally scoped variable

    // --- MODIFICATION: Store original indicator order ---
    // Process indicators (get names)
    const indicators = features.columns.filter(c => !["CA", "GEOG", "Crime_Rate"].includes(c));
    // Store the original order of indicator keys (columns)
    originalIndicatorOrder = [...indicators]; // Create a copy
    console.log("Original Indicator Order:", originalIndicatorOrder);
    // --- END MODIFICATION ---

    // Initialize indicator scales
    indicators.forEach(key => {
      const values = features.map(d => +d[key]).filter(v => !isNaN(v));
      if (values.length > 0) {
          indicatorScales[key] = d3.scaleLinear().domain(d3.extent(values)).range([0, 1]);
      } else {
          console.warn(`No valid data for indicator scale: ${key}`)
      }
    });

    // --- Process Crime Data ---
    // Calculate Average Crime Rate per CA (for map color & spikes)
    const avgCrimeByCA = d3.rollup(crimes, v => d3.mean(v, d => d.Crime_Rate), d => d.CA);
    console.log("Average Crime Rate by CA (for map color & spikes):", avgCrimeByCA);

    // Calculate Crime Counts Grouped by Category (for doughnut)
    crimeByCategory = d3.rollups(crimeGroup, v => d3.sum(v, d => d.Crime_Count), d => d.CA, d => d.Crime_Category);

    // --- Map Coloring Logic based on Average Crime Rate ---
    const validAvgRates = Array.from(avgCrimeByCA.values()).filter(d => d != null && !isNaN(d));
    const maxAvgCrimeRate = d3.max(validAvgRates);
    const minAvgCrimeRate = d3.min(validAvgRates);
    console.log(`Average Crime Rate range for color scale: ${minAvgCrimeRate} - ${maxAvgCrimeRate}`);
    const avgRateColorScale = d3.scaleSequential(d3.interpolateBlues)
     .domain([minAvgCrimeRate > 0 ? minAvgCrimeRate : 0, maxAvgCrimeRate]);
    // --- End Map Coloring Logic ---

    const projection = d3.geoMercator();
    const path = d3.geoPath().projection(projection);
    projection.fitSize([width, height], geojson);

    const mapGroup = svg.append("g");

    svg.call(
      d3.drag()
        .on("drag", function (event) {
          if (currentScale === 1) return;
          currentTranslate[0] += event.dx;
          currentTranslate[1] += event.dy;
          mapGroup.attr("transform", `translate(${currentTranslate}) scale(${currentScale})`);
        })
    );

    // 1. Create a Map for quick lookup of features by lowercase community name
    const communityNameMap = new Map();
    geojson.features.forEach(feature => {
      if (feature.properties && feature.properties.community) {
        communityNameMap.set(feature.properties.community.toLowerCase(), feature);
      }
    });

    // 2. Populate the datalist with community area names
    const datalist = d3.select("#ca-list");
    // Get all community names directly from the GeoJSON features
    const communityNames = geojson.features
        .map(feature => feature.properties.community) // Extract names
        .filter(name => name); // Filter out any potential null/undefined names

    // Sort the names alphabetically (case-insensitive using localeCompare)
    communityNames.sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }));

    // Append the sorted names as options to the datalist
    communityNames.forEach(communityName => {
      datalist.append("option").attr("value", communityName);
    });

   // 3. Add event listener to the search input
  d3.select("#ca-search").on("change", function(event) {
    const searchTerm = this.value.trim(); // Get entered value
    const lowerCaseSearchTerm = searchTerm.toLowerCase();

    // Clear the input after selection/change attempt
    this.value = '';

    if (searchTerm === "") return; // Ignore empty input

    const matchedFeature = communityNameMap.get(lowerCaseSearchTerm);

    if (matchedFeature) {
      console.log("Found CA:", matchedFeature.properties.community);

      const caId = +matchedFeature.properties.area_num_1;
      const community = matchedFeature.properties.community;

      // Check if it's the currently active CA - if so, do nothing
      if (activeCA === caId) {
        console.log("CA is already active, no changes made.");
        return;
      }

      // Set the new active CA
      activeCA = caId;

      // Hide static overview, Show charts for selected CA
      d3.select("#static-card").classed("hidden", true);
      d3.select("#doughnut").classed("hidden", false);
      d3.select("#indicators-card").classed("hidden", false);

      // Log visibility changes
      console.log("Static card hidden, dynamic charts shown.");

      // Render the static chart
      renderStaticChart();

      // Update path styles
      svg.selectAll("path.community")
        .classed("selected", d => +d.properties.area_num_1 === caId)
        .classed("dimmed", d => +d.properties.area_num_1 !== caId);

      // Draw the doughnut and indicator charts for the selected CA
      drawRightChart(caId, community);

      // Calculate zoom/pan transform
      const [[x0, y0], [x1, y1]] = path.bounds(matchedFeature);
      const dx = x1 - x0;
      const dy = y1 - y0;
      const x = (x0 + x1) / 2;
      const y = (y0 + y1) / 2;
      const targetScale = Math.max(1, Math.min(8, 0.9 / Math.max(dx / width, dy / height)));
      const adjustedScale = 1 + (targetScale - 1) / 64;
      const translate = [width / 2 - adjustedScale * x, height / 2 - adjustedScale * y];

      currentScale = adjustedScale; // Update global state
      currentTranslate = translate; // Update global state

      // Apply the zoom/pan transition
      mapGroup.transition()
        .duration(750)
        .ease(d3.easeCubicInOut)
        .attr("transform", `translate(${translate}) scale(${adjustedScale})`);

      document.getElementById("map-panel").classList.add("zoomed-in");

    } else {
      console.log("No CA found matching:", searchTerm);
      // Optional: Add feedback to the user, e.g., briefly change input border color
      d3.select(this).style("border-color", "red").transition().duration(1000).style("border-color", "#ccc");
    }
  });

    const spikeScale = d3.scaleLinear().domain([0, maxAvgCrimeRate]).range([0, 100]);

    mapGroup.selectAll("path")
      .data(geojson.features)
      .join("path")
      .attr("class", "community")
      .attr("d", path)
      .style("fill", d => {
        const caId = +d.properties.area_num_1;
        const avgRate = avgCrimeByCA.get(caId);
        return (avgRate != null && !isNaN(avgRate)) ? avgRateColorScale(avgRate) : "#eee";
      })
      .on("mouseover", (event, d) => {
        const caId = +d.properties.area_num_1;
        const communityName = d.properties.community;
        drawLineChart(caId, communityName);
        tooltip.style("opacity", 1);
      })
      .on("mousemove", (event) => {
          const tooltipNode = tooltip.node();
          const tooltipHeight = tooltipNode.offsetHeight;
          const verticalBuffer = 40;
          const containerRect = document.getElementById("map").getBoundingClientRect();
          const pageY = event.pageY;
          const pageX = event.pageX;
          let defaultTop = pageY - containerRect.top - 20;
          let defaultLeft = pageX - containerRect.left + 15;
          const bottomEdgeInContainer = defaultTop + tooltipHeight + verticalBuffer;
          const adjustedTop = bottomEdgeInContainer > containerRect.height
            ? defaultTop - tooltipHeight - verticalBuffer
            : defaultTop;
          const tooltipWidth = tooltipNode.offsetWidth;
          const rightEdgeInContainer = defaultLeft + tooltipWidth;
          const adjustedLeft = rightEdgeInContainer > containerRect.width
              ? defaultLeft - tooltipWidth - 30
              : defaultLeft;
          tooltip
            .style("left", `${adjustedLeft}px`)
            .style("top", `${adjustedTop}px`);
      })
      .on("mouseout", () => tooltip.style("opacity", 0))
      .on("click", (event, d) => {
        const caId = +d.properties.area_num_1;
        const community = d.properties.community;

        if (activeCA === caId) {
            // Deselect CA → Reset View
            activeCA = null;

            svg.selectAll("path.community")
              .classed("selected", false)
              .classed("dimmed", false);

            currentScale = 1;
            currentTranslate = [0, 0];

            mapGroup.transition()
              .duration(750)
              .ease(d3.easeCubicInOut)
              .attr("transform", `translate(0,0) scale(1)`);

            document.getElementById("map-panel").classList.remove("zoomed-in");

            // Show Static Chart with Animation
            showStaticPanel();

        } else {
            // Select New CA
            activeCA = caId;

            svg.selectAll("path.community")
              .classed("selected", dd => dd === d)
              .classed("dimmed", dd => dd !== d);

            // Show Doughnut + Indicators with Animation
            showRightPanel();

            // Draw CA Charts
            drawRightChart(caId, community);

            // Zoom In
            const [[x0, y0], [x1, y1]] = path.bounds(d);
            const dx = x1 - x0;
            const dy = y1 - y0;
            const x = (x0 + x1) / 2;
            const y = (y0 + y1) / 2;
            const targetScale = Math.max(1, Math.min(8, 0.9 / Math.max(dx / width, dy / height)));
            const adjustedScale = 1 + (targetScale - 1) / 64;
            const translate = [width / 2 - adjustedScale * x, height / 2 - adjustedScale * y];

            currentScale = adjustedScale;
            currentTranslate = translate;

            mapGroup.transition()
              .duration(750)
              .ease(d3.easeCubicInOut)
              .attr("transform", `translate(${translate}) scale(${adjustedScale})`);

            document.getElementById("map-panel").classList.add("zoomed-in");
        }
    });
      // Reset if clicking blank space in map-wrapper (outside CA)
      d3.select(".map-wrapper").on("click", function(event) {
        const isCommunity = event.target.closest("path.community");
        if (!isCommunity && activeCA !== null) {
          resetToStaticView();
        }
      });



      svg.on("click", function(event) {
  const isCommunity = event.target.closest("path.community");
  if (!isCommunity && activeCA !== null) {
    resetToStaticView();
  }
});


    mapGroup.append("g")
      .selectAll("polygon")
      .data(geojson.features.filter(d => {
          const caId = +d.properties.area_num_1;
          return avgCrimeByCA.has(caId) && avgCrimeByCA.get(caId) != null;
      }))
      .join("polygon")
      .attr("class", "spike")
      .attr("points", d => {
          const [x, y] = path.centroid(d);
          const caId = +d.properties.area_num_1;
          const rate = avgCrimeByCA.get(caId);
          const spikeHeight = (rate && rate > 0) ? spikeScale(rate) : 0;
          const finalHeight = Math.max(0, spikeHeight);
          const baseWidth = spikeWidth / currentScale;
          return [
            [x, y - finalHeight],
            [x - baseWidth / 2, y],
            [x + baseWidth / 2, y]
          ].map(p => p.join(",")).join(" ");
      });

    renderStaticChart();

    // --- Tooltip Line Chart ---
    function drawLineChart(caId, communityName) {
       const yearlyData = Array.from(
        d3.group(
          crimes.filter(d => d.CA === caId),
          d => d.Year
        ),
        ([year, values]) => ({
          date: new Date(+year, 0, 1),
          rate: d3.mean(values, d => d.Crime_Rate)
        })
      ).sort((a, b) => a.date - b.date);
      const overallAvgRate = avgCrimeByCA.get(caId);
      tooltipHeader.html(`
        <strong>${communityName} (CA ${caId})</strong><br>
        Avg. Crime Rate: ${overallAvgRate != null ? overallAvgRate.toFixed(2) : 'N/A'}`
      );
      chartSvg.selectAll("*").remove();
      const margin = { top: 10, right: 10, bottom: 25, left: 35 };
      const chartWidth = 280, chartHeight = 120;
      const innerWidth = chartWidth - margin.left - margin.right;
      const innerHeight = chartHeight - margin.top - margin.bottom;
      if (!yearlyData || yearlyData.length === 0 || !yearlyData.some(d => d.rate != null && !isNaN(d.rate))) {
          chartSvg.append("text").attr("x", chartWidth / 2).attr("y", chartHeight / 2).attr("text-anchor", "middle").attr("font-size", "12px").attr("fill", "#888").text("Crime rate data not available"); return;
      }
      const x = d3.scaleTime().domain(d3.extent(yearlyData, d => d.date)).range([0, innerWidth]);
      const yDomain = d3.extent(yearlyData, d => d.rate);
      const y = d3.scaleLinear().domain([0, yDomain[1]]).nice().range([innerHeight, 0]);
      const g = chartSvg.attr("width", chartWidth).attr("height", chartHeight).append("g").attr("transform", `translate(${margin.left},${margin.top})`);
      const area = d3.area().defined(d => !isNaN(d.rate)).x(d => x(d.date)).y0(innerHeight).y1(d => y(d.rate));
      g.append("path").datum(yearlyData).attr("fill", "lightsteelblue").attr("opacity", 0.7).attr("d", area);
      g.append("path").datum(yearlyData).attr("fill", "none").attr("stroke", "#4682b4").attr("stroke-width", 1.5).attr("d", d3.line().defined(d => !isNaN(d.rate)).x(d => x(d.date)).y(d => y(d.rate)));
      g.append("g").attr("class", "y-axis").call(d3.axisLeft(y).ticks(3).tickSize(-innerWidth).tickPadding(4)).call(g => g.select(".domain").remove()).call(g => g.selectAll(".tick line").attr("stroke", "#ddd"));
      g.append("g").attr("class", "x-axis").attr("transform", `translate(0,${innerHeight})`).call(d3.axisBottom(x).ticks(d3.timeYear.every(4)).tickFormat(d3.timeFormat("%Y")).tickPadding(4)).call(g => g.select(".domain").remove()).call(g => g.selectAll(".tick line").remove());
      g.selectAll(".y-axis text, .x-axis text").attr("font-size", "9px").attr("fill", "#555");
    }

    function renderStaticChart() {
      const svgStatic = d3.select("#static-chart");
      svgStatic.selectAll("*").remove();

      const outerWidth = svgStatic.node().getBoundingClientRect().width;
      const outerHeight = svgStatic.node().getBoundingClientRect().height;

      const margin = { top: 10, right: 10, bottom: 25, left: 35 };
      const width = outerWidth - margin.left - margin.right;
      const height = outerHeight - margin.top - margin.bottom;

      svgStatic
        .attr("viewBox", `0 0 ${outerWidth} ${outerHeight}`)
        .attr("preserveAspectRatio", "xMidYMid meet");

      const g = svgStatic.append("g")
        .attr("transform", `translate(${margin.left},${margin.top})`);

      // 1. Crime Counts By CA
      const crimeCountsByCA = d3.rollup(
        crimeGroupbyYear,
        v => d3.sum(v, d => d.Crime_Count),
        d => d.CA
      );

      topFeatures.forEach(d => {
        if (!crimeCountsByCA.get(d.CA)) console.warn("Missing Crime Count for CA:", d.CA);
        if (!d.Crime_Rate || d.Crime_Rate <= 0) console.warn("Invalid Crime Rate for CA:", d.CA);
        if (!d.unemployment_rate || d.unemployment_rate <= 0) console.warn("Invalid Unemployment Rate for CA:", d.CA);
        if (!d.rent_to_income || d.rent_to_income <= 0) console.warn("Invalid Rent Income Ratio for CA:", d.CA);
      });

      // 2. Calculate Total Population Proxy
      const totalPopulation = d3.sum(topFeatures, d => {
        const crimeCount = crimeCountsByCA.get(d.CA) || 1;
        return (d.Crime_Rate > 0) ? crimeCount / d.Crime_Rate : 0;
      });

      // 3. Top Crime Category Calculations
      const crimeCountsByCategory = d3.rollup(
        crimeGroupbyYear,
        v => d3.sum(v, d => d.Crime_Count),
        d => d.Crime_Category
      );

      // Convert the Map to an array and sort it
      const sortedCrimeCounts = Array.from(crimeCountsByCategory.entries())
        .sort((a, b) => d3.descending(a[1], b[1])); // Sort by count in descending order

      // Get the top crime category and its count
      const topCrimeCategory = sortedCrimeCounts[0] || ["N/A", 0]; // Default to ["N/A", 0] if no data

      // Calculate the percentage of the top crime category
      const totalCrimeCount = d3.sum(sortedCrimeCounts, d => d[1]); // Total crime count
      const topCrimeCategoryPercentage = totalCrimeCount > 0 ? (topCrimeCategory[1] / totalCrimeCount) * 100 : 0;

      // Update the topCrimes content to show the top crime category and its percentage
      d3.select("#summary1-content").html(
        isFinite(topCrimeCategoryPercentage) && topCrimeCategoryPercentage > 0
          ? `${topCrimeCategory[0]}:<br>${topCrimeCategoryPercentage.toFixed(1)}%`
          : "N/A"
      );

      // 4. YoY growth
      // Assuming crimeGroupbyYear is already available for 2023 and 2024

      // 1. Filter the data for the years 2023 and 2024
      const crime2023 = crimeGroupbyYear.filter(d => d.Year === 2023);
      const crime2024 = crimeGroupbyYear.filter(d => d.Year === 2024);

      // 2. Calculate the total crime count for each year
      const totalCrimeCount2023 = d3.sum(crime2023, d => d.Crime_Count);
      const totalCrimeCount2024 = d3.sum(crime2024, d => d.Crime_Count);

      // 3. Calculate Year-over-Year Growth
      const yoyGrowth = totalCrimeCount2023 > 0 
        ? ((totalCrimeCount2024 - totalCrimeCount2023) / totalCrimeCount2023) * 100 
        : 0;

      // 4. Display the results under #summary2-content
      d3.select("#summary2-content").html(
        `YoY 23-24:<br>${yoyGrowth.toFixed(2)}%`
      );

      // Line Chart Data
      const yearlyCrime = d3.rollups(
        crimeGroupbyYear,
        v => d3.sum(v, d => d.Crime_Count),
        d => d.Year
      ).map(([Year, Total]) => ({ Year: +Year, Total }));

      const x = d3.scaleLinear()
        .domain(d3.extent(yearlyCrime, d => d.Year))
        .range([0, width]);

      const y = d3.scaleLinear()
        .domain([0, d3.max(yearlyCrime, d => d.Total)])
        .nice()
        .range([height, 0]);

      g.append("path")
        .datum(yearlyCrime)
        .attr("fill", "none")
        .attr("stroke", "#4682b4")
        .attr("stroke-width", 2)
        .attr("d", d3.line()
          .x(d => x(d.Year))
          .y(d => y(d.Total))
        );

      g.append("g")
        .call(d3.axisLeft(y).ticks(4).tickSizeOuter(0));

      g.append("g")
        .attr("transform", `translate(0,${height})`)
        .call(d3.axisBottom(x).ticks(5).tickFormat(d3.format("d")).tickSizeOuter(0));

      // Function to lighten a color
      function lightenColor(color, percent) {
        const num = parseInt(color.slice(1), 16); // Convert hex to RGB
        const amt = Math.round(2.55 * percent); // Calculate the amount to lighten
        const r = (num >> 16) + amt; // Extract red
        const g = (num >> 8 & 0x00FF) + amt; // Extract green
        const b = (num & 0x0000FF) + amt; // Extract blue

        // Ensure values are within 0-255 range
        const newR = Math.min(255, Math.max(0, r));
        const newG = Math.min(255, Math.max(0, g));
        const newB = Math.min(255, Math.max(0, b));

        return `#${(0x1000000 + (newR << 16) + (newG << 8) + newB).toString(16).slice(1)}`; // Convert back to hex
      }

      // Ranking Box Generator
      function buildRankSection(title, items, valueFormatter) {
        const baseColor = "#D95F0E"; // Base color for the top rank

        return `
          <div style="display: flex; flex-direction: column; gap: 8px;">
            <!-- 1st Place Grand Card -->
            <div style="
                background: #fafafa;
                border: 1px solid #ddd;
                border-radius: 6px;
                padding: 12px;
                text-align: center;
            ">
              <div style="font-size: 24px; font-weight: bold; color: ${baseColor};">${items[0][0]}</div>
              <div style="font-size: 13px; color: #888;">${valueFormatter(items[0][1])}</div>
            </div>

            <!-- 2nd & 3rd Place Small Cards -->
            <div style="display: flex; gap: 6px;">
              ${items.slice(1).map(([label, value], idx) => {
                // Lighten the base color for 2nd and 3rd places
                const color = idx === 0 ? lightenColor(baseColor, 20) : lightenColor(baseColor, 40); // 20% lighter for 2nd, 40% for 3rd

                return `
                  <div style="
                      flex: 1;
                      background: #fafafa;
                      border: 1px solid #ddd;
                      border-radius: 6px;
                      padding: 8px;
                      text-align: center;
                  ">
                    <div style="font-size: 16px; font-weight: bold; color: ${color};">${label}</div>
                    <div style="font-size: 10px; color: #aaa;">${valueFormatter(value)}</div>
                  </div>
                `;
              }).join('')}
            </div>
          </div>
        `;
      }

      // Top Crime Categories
      const categoryTotals = d3.rollups(
        crimeGroupbyYear,
        v => d3.sum(v, d => d.Crime_Count),
        d => d.Crime_Category
      ).sort((a, b) => d3.descending(a[1], b[1])).slice(0, 3);

      d3.select("#top-category-content").html(
        buildRankSection("Top Crime Category", categoryTotals, d => `${d.toLocaleString()} Reports`)
      );

      // Safest Areas
      const safestAreas = topFeatures
        .slice()
        .sort((a, b) => a.Crime_Rate - b.Crime_Rate)
        .map(d => [d.GEOG, d.Crime_Rate])
        .slice(0, 3);

      d3.select("#safest-ca-content").html(
        buildRankSection("Safest Area", safestAreas, d => `Crime Rate: ${d.toFixed(2)}`)
      );

      // Most Crime-Ridden Areas
      const highestAreas = topFeatures
        .slice()
        .sort((a, b) => b.Crime_Rate - a.Crime_Rate)
        .map(d => [d.GEOG, d.Crime_Rate])
        .slice(0, 3);

      d3.select("#highest-ca-content").html(
        buildRankSection("Most Crime-Ridden", highestAreas, d => `Crime Rate: ${d.toFixed(2)}`)
      );
    }

    // --- Right Panel Charts ---
    function drawRightChart(caId, community) {
      renderDoughnutChart(caId, community);
      renderIndicators(caId); // This needs the updated sorting logic
    }
    
    function showRightPanel() {
      d3.select("#static-layout").style("display", "none");
      d3.select("#dynamic-layout")
        .style("display", "flex")
        .classed("slide-in", true);
    }

    function showStaticPanel() {
      d3.select("#dynamic-layout")
        .classed("slide-out", true);

      setTimeout(() => {
        d3.select("#dynamic-layout")
          .style("display", "none")
          .classed("slide-out", false);

        d3.select("#static-layout")
          .style("display", "flex")
          .classed("slide-in", true);

        // Always re-render fresh static chart after layout is visible
        renderStaticChart();
      }, 400);
    }

    // --- Utility: Reset Entire View ---
    function resetToStaticView() {
      activeCA = null;
      svg.selectAll("path.community")
        .classed("selected", false)
        .classed("dimmed", false);
      
      currentScale = 1;
      currentTranslate = [0, 0];
      
      mapGroup.transition()
        .duration(750)
        .ease(d3.easeCubicInOut)
        .attr("transform", `translate(0,0) scale(1)`);

      document.getElementById("map-panel").classList.remove("zoomed-in");

      showStaticPanel();
    }

    // --- Doughnut Chart (Rank-Based Colors) ---
    function renderDoughnutChart(caId, community) {
      d3.select("#doughnut").classed("hidden", false);
      d3.select("#indicators-card").classed("hidden", false);
      doughnutTitle.html(`${community} <span style="font-weight:normal; font-size: 13px;">(CA ${caId})</span> – Crime by Category`);

      const caCrimeGroupData = crimeByCategory.find(d => +d[0] === caId);

      // Handle cases where data might be missing for the selected CA
      if (!caCrimeGroupData || !caCrimeGroupData[1] || caCrimeGroupData[1].length === 0) {
          doughnutSvg.selectAll("*").remove();
          d3.select("#legend").selectAll("*").remove();
          doughnutSvg.append("text")
             .attr("x", "50%")
             .attr("y", "50%")
             .attr("text-anchor", "middle")
             .attr("dominant-baseline", "middle")
             .attr("font-size", "10px")
             .attr("fill", "#888")
             .text("No crime category data available");
          return;
      }

      // --- Data Preparation ---
      const rawData = caCrimeGroupData[1].map(([category, count]) => ({ category, count }));
      const total = d3.sum(rawData, d => d.count);
      const totalFormatted = total.toLocaleString();

      // Calculate percentage and sort by count DESCENDING
      const sortedData = rawData.map(d => ({
          ...d,
          percentage: total > 0 ? d.count / total : 0
      })).sort((a, b) => b.count - a.count); // Sort high to low count

      // --- Color Scale Setup ---
      // Define the Rank-Based Palette (Highest Rank/Count -> Lowest Rank/Count)
      const rankBasedPalette = [
        '#d95f0e', // Rank 1 (Highest Count)
        '#fec44f', // Rank 2
        '#fee391', // Rank 3
        '#3182bd', // Rank 4
        '#4292c6', // Rank 5
        '#6baed6', // Rank 6
        '#a6bddb', // Rank 7
        '#c6dbef'  // Rank 8 (Lowest Count)
      ];

      // Create an Ordinal Scale mapping Category Name -> Color based on rank
      const rankColorScale = d3.scaleOrdinal()
        .domain(sortedData.map(d => d.category)) // Domain is sorted category names
        .range(rankBasedPalette.slice(0, sortedData.length)); // Range is palette (slice handles <8 categories)

      // --- SVG & Chart Setup ---
      doughnutSvg.selectAll("*").remove(); // Clear previous chart
      const doughnutWidth = doughnutSvg.node().getBoundingClientRect().width;
      const radius = Math.min(doughnutWidth / 2, 100) - 10; // Control overall size here
      const innerRadius = radius * 0.6; // Control thickness here

      doughnutSvg.attr("viewBox", `0 0 ${radius * 2 + 20} ${radius * 2 + 20}`)
                 .attr("preserveAspectRatio", "xMidYMid meet");

      const g = doughnutSvg.append("g")
                         .attr("transform", `translate(${radius + 10}, ${radius + 10})`);

      // Center Text Elements
      const centerText = g.append("g")
                          .attr("class", "center-text")
                          .attr("text-anchor", "middle");
      const titleText = centerText.append("text")
                                 .attr("y", -5)
                                 .attr("font-size", "10px")
                                 .attr("font-weight", "600")
                                 .attr("fill", "#444")
                                 .text("Total Crimes"); // Initial text
      const valueText = centerText.append("text")
                                 .attr("y", 10)
                                 .attr("font-size", "11px")
                                 .attr("font-weight", "bold")
                                 .attr("fill", "#333")
                                 .text(`${totalFormatted}`); // Initial text

      // Arc and Pie Generators
      const arc = d3.arc().innerRadius(innerRadius).outerRadius(radius);
      const pie = d3.pie().value(d => d.count).sort(null); // Use slice size, preserve input order
      const pieData = pie(sortedData); // Use sorted data to get slice angles in order

      let selectedCategory = null; // Track clicked slice

      // --- Draw Slices ---
      const slices = g.selectAll("path")
        .data(pieData) // Data with calculated angles, referencing sortedData items
        .join("path")
          .attr("fill", d => rankColorScale(d.data.category)) // Color based on rank via category name
          .attr("d", arc)
          .attr("data-category", d => d.data.category)
          .style("cursor", "pointer")
          .style("stroke", "#fff")
          .style("stroke-width", 1)
          .style("transition", "transform 0.2s ease, opacity 0.2s ease")
          .each(function(d) { this._current = d; }); // Store data for transitions

      // --- Slice Interactivity ---
      slices.on("mouseover", function(event, d) {
        if (selectedCategory !== d.data.category) {
          d3.select(this)
            .transition().duration(150)
            .attr("transform", "scale(1.04)");

          // Display category name and its percentage/count in center
          const percentFormatted = d.data.percentage < 0.001 && d.data.percentage > 0
              ? "<0.1%" : `${(d.data.percentage * 100).toFixed(1)}%`;
          titleText.text(d.data.category); // Use original category name for title
          valueText.text(`${d.data.count.toLocaleString()} (${percentFormatted})`);
        }
      }).on("mouseout", function(event, d) {
        if (selectedCategory !== d.data.category) {
          d3.select(this)
            .transition().duration(150)
            .attr("transform", "scale(1)");

          // Restore center text based on whether a slice is selected
          if (!selectedCategory) {
            titleText.text("Total Crimes");
            valueText.text(`${totalFormatted}`);
          } else {
            // Restore text of the currently selected slice
            const selectedData = sortedData.find(item => item.category === selectedCategory);
            if (selectedData) {
              const selectedPercentFormatted = selectedData.percentage < 0.001 && selectedData.percentage > 0
                  ? "<0.1%" : `${(selectedData.percentage * 100).toFixed(1)}%`;
              titleText.text(selectedCategory); // Use category name
              valueText.text(`${selectedData.count.toLocaleString()} (${selectedPercentFormatted})`);
            }
          }
        }
      }).on("click", function(event, d) {
        toggleSlice(d.data.category); // Use category name to toggle
        event.stopPropagation();
      });

      // --- Draw Legend ---
      const legend = d3.select("#legend");
      legend.selectAll("*").remove();

      // Create legend items using sorted data (so legend order matches rank)
      const legendItems = legend.selectAll(".legend-item")
        .data(sortedData)
        .join("div")
          .attr("class", "legend-item")
          .on("click", (event, d) => {
              toggleSlice(d.category);
              event.stopPropagation();
          });

      // Add color swatch based on rank
      legendItems.append("div")
        .attr("class", "legend-swatch")
        .style("background-color", d => rankColorScale(d.category));

      // Add text label (category name and count)
      legendItems.append("div")
        .attr("class", "legend-label")
        .text(d => `${d.category} (${d.count.toLocaleString()})`);
      
      // --- Slice Toggle Logic ---
      function toggleSlice(category) {
        const isSame = selectedCategory === category;
        if (isSame) { // Deselecting
          selectedCategory = null;
          slices.transition().duration(200)
            .attr("transform", "scale(1)")
            .style("opacity", 1);
          titleText.text("Total Crimes");
          valueText.text(`${totalFormatted}`);
        } else { // Selecting new category
          selectedCategory = category;
          slices.each(function(d) { // Dim non-selected, highlight selected
            const sliceEl = d3.select(this);
            const sliceCategory = d.data.category;
            if (sliceCategory === selectedCategory) {
              sliceEl.transition().duration(200).attr("transform", "scale(1.08)").style("opacity", 1);
            } else {
              sliceEl.transition().duration(200).attr("transform", "scale(0.95)").style("opacity", 0.6);
            }
          });
          // Update center text for selected slice
          const selectedData = sortedData.find(d => d.category === category);
          const percentFormatted = selectedData.percentage < 0.001 && selectedData.percentage > 0
              ? "<0.1%" : `${(selectedData.percentage * 100).toFixed(1)}%`;
          titleText.text(category);
          valueText.text(`${selectedData.count.toLocaleString()} (${percentFormatted})`);
        }
        // Update legend item appearance
        legend.selectAll(".legend-item")
          .classed("clicked", d => d.category === selectedCategory)
          .style("opacity", d => (!selectedCategory || d.category === selectedCategory) ? 1 : 0.6);
      }
    } // End of renderDoughnutChart

    // --- Indicators Panel ---
    const sortToggle = d3.select("#sort-toggle");

    function updateSortToggleText() {
        if (currentSortMode === 'importance') {
            sortToggle.text("⭐ Sorted by Importance");
            sortToggle.attr("title", "Sorted by importance (Default CSV order)");
        } else if (currentSortMode === 'descending') {
            sortToggle.text("▼ Descending");
            sortToggle.attr("title", "Sorted by value descending");
        } else { // ascending
            sortToggle.text("▲ Ascending");
            sortToggle.attr("title", "Sorted by value ascending");
        }
    }
    updateSortToggleText(); // Set initial text

    sortToggle.on("click", () => {
        if (currentSortMode === 'importance') {
            currentSortMode = 'descending';
        } else if (currentSortMode === 'descending') {
            currentSortMode = 'ascending';
        } else { // current was 'ascending'
            currentSortMode = 'importance';
        }
        updateSortToggleText();
        if (activeCA !== null) {
            renderIndicators(activeCA); // Re-render indicators with new sort
        }
    });

    function renderIndicators(caId) {
        const indicatorsDiv = d3.select("#indicators"); indicatorsDiv.selectAll("*").remove();
        const indicatorRowData = topFeatures.find(d => +d.CA === caId);
        if (!indicatorRowData) { indicatorsDiv.html('<p style="font-size: 12px; color: #888; padding: 10px;">Socio-economic data not available for this area.</p>'); return; }
        if (!indicatorScales || Object.keys(indicatorScales).length === 0) { console.error("Indicator scales have not been initialized properly."); indicatorsDiv.html('<p style="font-size: 12px; color: red; padding: 10px;">Error: Indicator scales missing.</p>'); return; }

        // Map raw data, ensuring rawKey is included
        let indicatorsData = Object.entries(indicatorRowData)
            .filter(([key]) => !["CA", "GEOG", "Crime_Rate"].includes(key) && indicatorScales[key])
            .map(([key, value]) => {
                const scale = indicatorScales[key];
                const numericValue = +value;
                const scaledValue = (scale && !isNaN(numericValue)) ? scale(numericValue) : 0;
                const clampedScaledValue = Math.max(0, Math.min(1, scaledValue));
                const formattedLabel = key.replace(/_/g, " ").replace(/\b\w/g, c => c.toUpperCase());
                let formattedValueDisplay;
                if (!isNaN(numericValue)) {
                    // Always format as a number using locale string. Adjust digits as needed.
                    formattedValueDisplay = numericValue.toLocaleString(undefined, {
                        minimumFractionDigits: 0, // Don't force decimals if it's a whole number
                        maximumFractionDigits: 2  // Show up to 2 decimal places if they exist
                    });
                } else {
                    formattedValueDisplay = "N/A";
                    }
                return {
                    label: formattedLabel,
                    rawValue: numericValue,
                    scaledValue: clampedScaledValue,
                    displayValue: formattedValueDisplay,
                    rawKey: key // Include original key
                };
            })
            .filter(d => !isNaN(d.rawValue));

        // Apply sorting based on currentSortMode
        if (currentSortMode === 'importance') {
            if (typeof originalIndicatorOrder !== 'undefined') {
                 // Sort based on index in originalIndicatorOrder
                 indicatorsData.sort((a, b) => originalIndicatorOrder.indexOf(a.rawKey) - originalIndicatorOrder.indexOf(b.rawKey));
            } else {
                console.error("originalIndicatorOrder is not defined. Cannot sort by importance.");
            }
        } else if (currentSortMode === 'ascending') {
            indicatorsData.sort((a, b) => a.scaledValue - b.scaledValue);
        } else { // 'descending'
            indicatorsData.sort((a, b) => b.scaledValue - a.scaledValue);
        }
        // --- End Sorting Logic Modification ---

        if (indicatorsData.length === 0) { indicatorsDiv.html('<p style="font-size: 12px; color: #888; padding: 10px;">No applicable indicators found.</p>'); return; }

        indicatorsDiv.selectAll(".indicator-row")
            .data(indicatorsData)
            .enter()
            .append("div")
            .attr("class", "indicator-row")
            .html(d => {
                const widthPct = d.scaledValue * 100;
                return `
                  <div class="indicator-label">${d.label}: ${d.displayValue}</div>
                  <div class="indicator-bar-container">
                    <div
                      class="indicator-bar-fill"
                      style="width: ${widthPct.toFixed(2)}%; background-color: ${d.scaledValue * 100 > 66 ? '#d95f0e' : d.scaledValue * 100 > 33 ? '#fec44f' : '#a6bddb'};"
                    ></div>
                  </div>
                `;
            });
     }
  }).catch(error => {
    console.error("Error loading data:", error);
    d3.select("#dashboard").html(`<div style="padding: 20px; color: red; font-weight: bold;">Failed to load required data. Please check the console for details and ensure data files are accessible. Error: ${error.message}</div>`);
  });

</script>

</body>
</html>
